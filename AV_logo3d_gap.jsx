/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/AV_logo3d_gap.glb 
*/

import React, { useRef, useMemo } from 'react'
import { useGLTF, MeshTransmissionMaterial } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import * as THREE from 'three'

// Color Constants
const BRAND_CYAN = "#009FE3"
const WHITE_SILVER = "#F0F0F0"
const WHITE_GLOW = "#FFFFFF"
const CYAN_GLOW = "#009FE3"

export function AV_logo3d_gap(props) {
  const group = useRef()
  const { nodes } = useGLTF(import.meta.env.BASE_URL + 'models/AV_logo3d_gap.glb')

  // Categorize nodes
  const { cores, shells, textParts } = useMemo(() => {
    const cores = []
    const shells = []
    const textParts = []
    
    Object.values(nodes).forEach((node) => {
      if (node.isMesh) {
        const name = node.name;
        const lowerName = name.toLowerCase();
        
        // Cores (inner parts)
        if (lowerName.includes('core') || lowerName.endsWith('c')) {
          cores.push(node)
        } 
        // Shells (outer parts starting with l1, l2, l3, l4 followed by numbers)
        else if (name.startsWith('l')) {
          shells.push(node)
        } 
        // Text (numbers 1-12)
        else {
            // Check if it's one of the number nodes
            if (!isNaN(parseInt(name))) {
                textParts.push(node)
            }
        }
      }
    })
    return { cores, shells, textParts }
  }, [nodes])

  // Combined refs for all interactive elements (Shells + Text)
  const animatedRefs = useRef([])

  useFrame((state, delta) => {
    const { pointer, camera } = state
    
    // 1. Idle Animation
    if (group.current) {
      // Gentle swaying
      group.current.rotation.y = Math.sin(state.clock.elapsedTime * 0.5) * 0.3
    }

    // 2. Mouse Interaction
    const vec = new THREE.Vector3(pointer.x, pointer.y, 0.5)
    vec.unproject(camera)
    const dir = vec.sub(camera.position).normalize()
    const distanceToPlane = -camera.position.z / dir.z 
    const mouseWorldPos = camera.position.clone().add(dir.multiplyScalar(distanceToPlane))
    
    // Calculate distance from "mouse world position" to the group center
    const groupWorldPos = new THREE.Vector3()
    if (group.current) {
        group.current.getWorldPosition(groupWorldPos)
    } else {
        groupWorldPos.set(2.5, 0, 0) // Fallback
    }

    const dist = mouseWorldPos.distanceTo(groupWorldPos)
    
    // Thresholds
    const proximityThreshold = 2.5
    const intensity = Math.max(0, 1 - dist / proximityThreshold)
    
    // Animate all interactive parts (Shells + Text)
    animatedRefs.current.forEach((ref, i) => {
      if (!ref) return
      
      const originalPos = ref.userData.originalPos
      const originalRot = ref.userData.originalRot
      const randomDir = ref.userData.randomDir 
      
      if (!originalPos || !originalRot || !randomDir) return

      // Explosion Direction
      let direction = originalPos.clone().normalize()
      if (direction.length() < 0.001) direction.copy(randomDir)
      
      // Mix: 40% original direction + 60% random scatter
      direction.lerp(randomDir, 0.6).normalize()
      
      const explosionDist = 2.5 
      const targetPos = originalPos.clone().add(direction.multiplyScalar(intensity * explosionDist))
      
      // Chaos rotation
      const chaosRotX = originalRot.x + (intensity * Math.sin(state.clock.elapsedTime * 3 + i) * 2.0)
      const chaosRotY = originalRot.y + (intensity * Math.cos(state.clock.elapsedTime * 2 + i) * 2.0)
      const chaosRotZ = originalRot.z + (intensity * Math.sin(state.clock.elapsedTime * 2.5 + i) * 2.0)
      
      // Lerp
      ref.position.lerp(targetPos, 0.1)
      ref.rotation.x = THREE.MathUtils.lerp(ref.rotation.x, chaosRotX, 0.1)
      ref.rotation.y = THREE.MathUtils.lerp(ref.rotation.y, chaosRotY, 0.1)
      ref.rotation.z = THREE.MathUtils.lerp(ref.rotation.z, chaosRotZ, 0.1)
    })
  })

  // Helper to store initial transforms
  const bindRef = (el, index) => {
    if (el) {
      animatedRefs.current[index] = el
      if (!el.userData.originalPos) {
        el.userData.originalPos = el.position.clone()
        el.userData.originalRot = el.rotation.clone()
        el.userData.randomDir = new THREE.Vector3(
            Math.random() - 0.5, 
            Math.random() - 0.5, 
            Math.random() - 0.5
        ).normalize()
      }
    }
  }

  return (
    <group ref={group} {...props} dispose={null}>
      {/* 1. Cores (Inner Glowing Parts) */}
      {cores.map((node, i) => {
        const n = node.name.toLowerCase()
        // Logic: l1 or l3 -> White Glow, l2 or l4 -> Cyan Glow
        const isWhiteCore = n.includes('l1') || n.includes('l3')
        const color = isWhiteCore ? WHITE_GLOW : CYAN_GLOW
        
        return (
          <mesh
            key={node.name}
            geometry={node.geometry}
            position={node.position}
            rotation={node.rotation}
            scale={node.scale}
          >
            <meshStandardMaterial 
              color={color} 
              emissive={color} 
              emissiveIntensity={3} 
              toneMapped={false} 
            />
          </mesh>
        )
      })}

      {/* 2. Shells (Outer Glass Parts) */}
      {shells.map((node, i) => {
        const n = node.name
        // Logic: l1 or l3 -> White Shells, l2 or l4 -> Cyan Shells
        const isWhiteShell = n.startsWith('l1') || n.startsWith('l3')
        const color = isWhiteShell ? WHITE_SILVER : BRAND_CYAN
        
        return (
          <mesh
            key={node.name}
            ref={(el) => bindRef(el, i)} // First batch
            geometry={node.geometry}
            position={node.position}
            rotation={node.rotation}
            scale={node.scale}
          >
            <MeshTransmissionMaterial 
              backside={true}
              samples={2}
              resolution={256}
              thickness={0.2}
              chromaticAberration={0.1}
              anisotropy={0.1}
              distortion={0.5}
              distortionScale={0.5}
              temporalDistortion={0.1}
              attenuationDistance={0.5}
              attenuationColor="#ffffff"
              color={color} // Use specific color again (not fixed white)
              roughness={0.1}
              metalness={0.5}
            />
          </mesh>
        )
      })}

      {/* 3. Text (Letters) */}
      {textParts.map((node, i) => {
        // Logic: Nodes are numbered 1-12
        // 1-5 (AIHIO) -> White
        // 6-12 (VISUALS) -> Cyan
        let isWhiteText = false
        const num = parseInt(node.name)
        if (!isNaN(num) && num <= 5) {
            isWhiteText = true
        }
        
        const color = isWhiteText ? WHITE_SILVER : BRAND_CYAN
        
        return (
          <mesh
            key={node.name}
            ref={(el) => bindRef(el, shells.length + i)} // Offset indices
            geometry={node.geometry}
            position={node.position}
            rotation={node.rotation}
            scale={node.scale}
          >
            <meshStandardMaterial 
              color={color}
              roughness={0.3}
              metalness={0.8}
            />
          </mesh>
        )
      })}
    </group>
  )
}

useGLTF.preload(import.meta.env.BASE_URL + 'models/AV_logo3d_gap.glb')
