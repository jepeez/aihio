/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useMemo } from 'react'
import { useGLTF, MeshTransmissionMaterial } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import * as THREE from 'three'

// Color Constants
const BRAND_CYAN = "#009FE3"
const WHITE_SILVER = "#F0F0F0"
const WHITE_GLOW = "#FFFFFF"
const CYAN_GLOW = "#009FE3"

// Reusable Material Props for Consistency - Optimized for Performance
const materialProps = {
    backside: false, // Disabled for performance
    samples: 6, // Reduced from 16
    resolution: 256, // Reduced from 1024
    thickness: 1.5,
    chromaticAberration: 0.15,
    anisotropy: 0, // Disabled
    distortion: 0.2,
    distortionScale: 0.2,
    temporalDistortion: 0, // Disabled
    attenuationDistance: 0.5,
    attenuationColor: "#ffffff",
    roughness: 0.1,
    metalness: 0.5
}

// Further optimized props for the many small shards
const shardMaterialProps = {
    ...materialProps,
    samples: 2, // Drastically reduced for shards (they move fast)
    resolution: 128, // Lower resolution is fine for small shards
    distortion: 0.1, // Less distortion calculation
    chromaticAberration: 0.1,
}

export function AV_logo3d(props) {
    const group = useRef()

    // Load both models
    // AV.glb = Whole one piece model (Solid state)
    // AV1.glb = Explosion parts (Fractured state)
    const { nodes: solidNodes } = useGLTF(import.meta.env.BASE_URL + 'models/AV.glb')
    const { nodes: partsNodes } = useGLTF(import.meta.env.BASE_URL + 'models/AV1.glb', true) // Enable Draco

    // Refs for groups
    const solidGroupRef = useRef()
    const fracturedGroupRef = useRef()

    // 1. Process SOLID Model (AV.glb)
    const { cores, solidShells, localCenter } = useMemo(() => {
        const cores = []
        const solidShells = []
        const positions = []

        // Note: AV.glb appears to be empty in current check, but we implement logic for it.
        // If user updates the file, this should work.
        if (solidNodes) {
            Object.values(solidNodes).forEach((node) => {
                if (node.isMesh) {
                    positions.push(node.position)
                    // Basic heuristic since we don't know node names yet for AV.glb
                    // Assuming similar structure or just treating all as shell for now
                    solidShells.push(node)
                }
            })
        }

        // If solid is empty, fallback to using Parts as solid (assembled)
        // But Parts are fractured. 

        // Calculate centroid (use parts if solid is empty to ensure centering works)
        const nodesForCenter = positions.length > 0 ? solidNodes : partsNodes

        Object.values(nodesForCenter || {}).forEach((node) => {
            if (node.isMesh) positions.push(node.position)
        })

        const box = new THREE.Box3()
        if (positions.length > 0) {
            box.setFromPoints(positions)
        }
        const center = new THREE.Vector3()
        if (!box.isEmpty()) {
            box.getCenter(center)
        }

        return { cores, solidShells, localCenter: center }
    }, [solidNodes, partsNodes])

    // 2. Process PARTS Model (EXAV.glb)
    const fracturedShells = useMemo(() => {
        const shells = []

        if (partsNodes) {
            Object.values(partsNodes).forEach((node) => {
                if (node.isMesh) {
                    // Generate stable random data for this shard
                    const randomDir = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize()
                    const randomAxis = new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize()

                    shells.push({
                        node,
                        randomDir,
                        randomAxis,
                        speed: 0.5 + Math.random() * 1.5
                    })
                }
            })
        }
        return { shells }
    }, [partsNodes])

    // Refs for animating the fractured parts
    const animatedRefs = useRef([])
    const intensityRef = useRef(0) // Store smoothed intensity

    useFrame((state, delta) => {
        const { pointer, camera } = state
        const time = state.clock.elapsedTime

        // 2. Interaction Logic
        const vec = new THREE.Vector3(pointer.x, pointer.y, 0.5)
        vec.unproject(camera)
        const dir = vec.sub(camera.position).normalize()

        // Updated default position based on HeroScene: [0.6, 2.5, 0]
        const groupWorldPos = new THREE.Vector3()
        if (group.current) {
            group.current.getWorldPosition(groupWorldPos)
        } else {
            groupWorldPos.set(0.6, 2.5, 0)
        }

        // Raycast to the exact Z plane of the object (handles floating Z)
        const planeZ = groupWorldPos.z
        const distanceToPlane = (planeZ - camera.position.z) / dir.z
        const mouseWorldPos = camera.position.clone().add(dir.multiplyScalar(distanceToPlane))

        // Standard Euclidean distance (uniform sensitivity)
        const dx = mouseWorldPos.x - groupWorldPos.x
        const dy = mouseWorldPos.y - groupWorldPos.y
        const dz = mouseWorldPos.z - groupWorldPos.z
        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz)

        const proximityThreshold = 2.5

        // Intro Sequence Logic
        const assembleStart = 0.5
        const assembleEndTime = 4.0
        const interactionStartTime = 4.5

        const isIntro = time < interactionStartTime

        let effectiveIntensity = 0
        let explosionScale = 1.0

        // Calculate Base Rotation + Idle Sway
        const baseY = props.rotation ? props.rotation[1] : 0

        // Sway +/- 30 degrees (approx 0.5 radians)
        // Speed 0.5 is good for a gentle sway
        const swayAmplitude = 0.5
        const idleSway = Math.sin(time * 0.7) * swayAmplitude

        if (isIntro) {
            if (group.current) {
                const spinProgress = Math.min(1.0, time / assembleEndTime)
                const spinOffset = (1 - Math.pow(spinProgress, 0.5)) * Math.PI * 6
                // Add spinOffset only during intro, + idleSway
                group.current.rotation.y = baseY - spinOffset + idleSway
            }

            if (time < assembleStart) {
                effectiveIntensity = 1.0
            } else if (time < assembleEndTime) {
                effectiveIntensity = Math.pow(1.0 - (time - assembleStart) / (assembleEndTime - assembleStart), 2.0)
            } else {
                effectiveIntensity = 0.0
            }

            effectiveIntensity = Math.max(0, effectiveIntensity)
            explosionScale = 1.5

            intensityRef.current = effectiveIntensity

        } else {
            if (group.current) {
                group.current.rotation.y = baseY + idleSway
            }

            let targetIntensity = 0

            if (!props.isMobile) {
                const rawTargetIntensity = Math.max(0, 1 - dist / proximityThreshold)
                targetIntensity = Math.pow(rawTargetIntensity, 1.5)
            }

            const isExploding = targetIntensity > intensityRef.current
            const lerpFactor = isExploding ? 0.25 : 0.05

            intensityRef.current = THREE.MathUtils.lerp(intensityRef.current, targetIntensity, lerpFactor)
            effectiveIntensity = intensityRef.current
            explosionScale = 1.0
        }

        // 3. Toggle Visibility
        // If solidShells is empty (bad AV.glb), we might want to show fracturedShells in assembled state?
        // For now, standard logic:
        const exploded = effectiveIntensity > 0.001
        // Pre-render for 1s to compile shaders/init FBOs to prevent lag at assembly
        const shaderWarmup = time < 1.0

        if (solidGroupRef.current) {
            // If we have solid shells, use them. 
            // If AV.glb is empty, this group is empty, so nothing renders.
            const shouldRender = !exploded || shaderWarmup
            solidGroupRef.current.visible = shouldRender

            if (shouldRender) {
                if (exploded && shaderWarmup) {
                    // Warmup: Render microscopically small to be invisible but compile shader
                    solidGroupRef.current.scale.setScalar(0.000001)
                } else {
                    // Normal Assembled State
                    solidGroupRef.current.scale.setScalar(1)
                }
            }
        }

        // If AV.glb is missing/empty, force fractured shells to be visible always?
        // Only if solidShells.length === 0
        const forceFracturedVisible = solidShells.length === 0

        if (fracturedGroupRef.current) {
            fracturedGroupRef.current.visible = exploded || forceFracturedVisible
        }

        // 4. Animate Fractured Shells
        if (exploded || forceFracturedVisible) {
            fracturedShells.shells.forEach((item, i) => {
                const ref = animatedRefs.current[i]
                if (!ref) return

                if (!ref.userData.originalPos) {
                    ref.userData.originalPos = ref.position.clone()
                    ref.userData.originalRot = ref.rotation.clone()
                    return
                }

                const originalPos = ref.userData.originalPos
                const originalRot = ref.userData.originalRot

                // Explosion
                const baseDist = 25.0
                const finalDist = baseDist * explosionScale
                const targetPos = originalPos.clone().add(item.randomDir.clone().multiplyScalar(effectiveIntensity * finalDist))

                // Rotation
                const maxRot = Math.PI * 1.5
                const targetRotX = originalRot.x + (item.randomAxis.x * effectiveIntensity * maxRot)
                const targetRotY = originalRot.y + (item.randomAxis.y * effectiveIntensity * maxRot)
                const targetRotZ = originalRot.z + (item.randomAxis.z * effectiveIntensity * maxRot)

                ref.position.lerp(targetPos, 0.1)
                ref.rotation.x = THREE.MathUtils.lerp(ref.rotation.x, targetRotX, 0.1)
                ref.rotation.y = THREE.MathUtils.lerp(ref.rotation.y, targetRotY, 0.1)
                ref.rotation.z = THREE.MathUtils.lerp(ref.rotation.z, targetRotZ, 0.1)
            })
        }
    })

    // Offset Vector to center geometry
    const centerOffset = useMemo(() => [-localCenter.x, -localCenter.y, -localCenter.z], [localCenter])

    return (
        <group ref={group} {...props} dispose={null}>
            <group position={centerOffset}>
                {/* 1. Solid Model (AV.glb) */}
                <group ref={solidGroupRef} visible={false}>
                    {solidShells.map((node, i) => {
                        return (
                            <mesh
                                key={node.name + i}
                                geometry={node.geometry}
                                position={node.position}
                                rotation={node.rotation}
                                scale={node.scale}
                            >
                                <MeshTransmissionMaterial
                                    {...materialProps}
                                    color={BRAND_CYAN}
                                />
                            </mesh>
                        )
                    })}
                </group>

                {/* 2. Fractured Model (EXAV.glb) */}
                <group ref={fracturedGroupRef} visible={true}>
                    {fracturedShells.shells.map((item, i) => {
                        const node = item.node
                        return (
                            <mesh
                                key={node.name + i}
                                ref={(el) => (animatedRefs.current[i] = el)}
                                geometry={node.geometry}
                                position={node.position}
                                rotation={node.rotation}
                                scale={node.scale}
                            >
                                <MeshTransmissionMaterial
                                    {...shardMaterialProps}
                                    color={BRAND_CYAN}
                                />
                            </mesh>
                        )
                    })}
                </group>
            </group>
        </group>
    )
}

useGLTF.preload(import.meta.env.BASE_URL + 'models/AV.glb')
useGLTF.preload(import.meta.env.BASE_URL + 'models/AV1.glb')
